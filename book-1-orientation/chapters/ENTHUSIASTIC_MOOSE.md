# Enthusiastic Moose

## A C# Exercise

Create a realistic simulation of a inquisitive _(and enthusiastic)_ moose.

The program should be written in increments. Each phase will add a little more complexity.

As you go through the phases make sure you...

1. Before you run it, consider how each code change will affect the program. What do you expect to happen?
1. Run the program after each change to confirm it does what it is supposed to do.
1. Commit your code after each phase.

### Phase 1

1. From your workspace directory, use the `dotnet` command to create a new .NET console application, and then change to the project directory

   ```sh
   dotnet new console -o EnthusiasticMoose
   cd EnthusiasticMoose
   ```

1. Run the program to ensure everything is working

   ```sh
   dotnet run
   ```

1. Add a gitignore to the project

   ```sh
   dnignore
   ```

   > **NOTE:** Make sure you run this command from the `EnthusiasticMoose` directory.

1. initialize a git repository and commit

### Phase 2

Make some changes to the initial project's source code.

1. Open the project in Visual Studio Code.
1. Open the `Program.cs` File.

   > **NOTE:** A file with a `.cs` extension is a C# source code file.

1. Remove all the code generated by the scaffolding process.
1. Add the appropriate code to print the following message to the console.

   ```sh
   Welcome to the Enthusiastic Moose Simulator!
   --------------------------------------------

   ```

### Phase 3

Our user wants to see the moose they're interacting with and learn what it has to say. Let's make that happen.

1. Create a `MooseSays()` function that displays the enthusiastic moose and let's it speak.

    > Program.cs

    ```cs
    using System;
    
    Console.WriteLine("Welcome to the Enthusiastic Moose Simulator!");
    Console.WriteLine("--------------------------------------------");
    Console.WriteLine();
    
    
    void MooseSays()
    {
        Console.WriteLine(@"
                                           _.--^^^--,
                                        .'          `\
      .-^^^^^^-.                      .'              |
     /          '.                   /            .-._/
    |             `.                |             |
     \              \          .-._ |          _   \
      `^^'-.         \_.-.     \   `          ( \__/
            |             )     '=.       .,   \
           /             (         \     /  \  /
         /`               `\        |   /    `'
         '..-`\        _.-. `\ _.__/   .=.
              |  _    / \  '.-`    `-.'  /
              \_/ |  |   './ _     _  \.'
                   '-'    | /       \ |
                          |  .-. .-.  |
                          \ / o| |o \ /
                           |   / \   |    H I, I'M  E N T H U S I A S T I C !
                          / `^`   `^` \
                         /             \
                        | '._.'         \
                        |  /             |
                         \ |             |
                          ||    _    _   /
                          /|\  (_\  /_) /
                          \ \'._  ` '_.'
                           `^^` `^^^`
        ");
    }
    ```

    > **NOTE:** We add an `@` in front of the string to allow for a _multi-line string_.

1. Just creating the `MooseSays()` function is not enough to see what it does. We must _call_ it. Add a line to invoke `MooseSays()` after the code that prints the welcome message.

    > **NOTE:** Don't forget the `;`

    > **NOTE:** Remember we also use the terms _invoke_ or _execute_ as synonyms for _"calling"_ a function.

### Phase 4

A moose that only says one thing isn't all that interesting. Let's give it the power to say anything we want by adding a parameter to the `MooseSays()` method.

1. Update the `MooseSays()` function to accept a `message` parameter and use _string interpolation_ to display the message next to the moose.

   ```cs
   void MooseSays(string message)
   {
       Console.WriteLine($@"
                                         _.--^^^--,
                                       .'          `\
     .-^^^^^^-.                      .'              |
    /          '.                   /            .-._/
   |             `.                |             |
    \              \          .-._ |          _   \
     `^^'-.         \_.-.     \   `          ( \__/
           |             )     '=.       .,   \
          /             (         \     /  \  /
        /`               `\        |   /    `'
        '..-`\        _.-. `\ _.__/   .=.
             |  _    / \  '.-`    `-.'  /
             \_/ |  |   './ _     _  \.'
                  '-'    | /       \ |
                         |  .-. .-.  |
                         \ / o| |o \ /
                          |   / \   |    {message}
                         / `^`   `^` \
                        /             \
                       | '._.'         \
                       |  /             |
                        \ |             |
                         ||    _    _   /
                         /|\  (_\  /_) /
                         \ \'._  ` '_.'
                          `^^` `^^^`
       ");
   }
   ```

   > **NOTE:** We added the `$` character to the front of the string to enable string interpolation.

1. Now that the function can accept a message, Let's update the code to get our moose to (enthusiastically) say a couple things.

    ```cs
    Console.WriteLine("Welcome to the Enthusiastic Moose Simulator!");
    Console.WriteLine("--------------------------------------------");
    Console.WriteLine();

    // Let the moose speak!
    MooseSays("H I, I'M  E N T H U S I A S T I C !");
    MooseSays("I really am enthusiastic");
    ```

## Phase 5

Our moose is an inquisitive moose, but doesn't have time (or the attention span) for long-winded answers. Only `yes/no` questions will do.

1. Add a function called `MooseAsks()` that will give the moose the power to ask a `yes/no` question.

    ```cs
    bool MooseAsks(string question)
    {
        Console.Write($"{question} (Y/N): ");
        string answer = Console.ReadLine().ToLower();
 
        while (answer != "y" && answer != "n")
        {
            Console.Write($"{question} (Y/N): ");
            answer = Console.ReadLine().ToLower();
        }
 
        if (answer == "y")
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    ```

1. Take a few moments to review the `MooseAsks()` function. Do you understand it? Could you comment the code to describe it's behavior? Could you explain it to an NSS student after their first week of learning JavaScript?
1. Call the `MooseAsks()` function and print out the response to verify everything works.

    ```cs
    Console.WriteLine("Welcome to the Enthusiastic Moose Simulator!");
    Console.WriteLine("--------------------------------------------");
    Console.WriteLine();

    // Let the moose speak!
    MooseSays("H I, I'M  E N T H U S I A S T I C !");
    MooseSays("I really am enthusiastic");

    // As a question
    bool isTrue = MooseAsks("Is Canada real?");
    Console.WriteLine(isTrue);
    ```

## Phase 6

Our moose can ask a question now, but it doesn't respond. Let's change that.

1. Now that know our `MooseAsks()` function works, we don't need to print the response. Remove the `Console.WriteLine(response);` line
1. Add code to allow the moose to say something based on the user's response to the question.

    ```cs
    Console.WriteLine("Welcome to the Enthusiastic Moose Simulator!");
    Console.WriteLine("--------------------------------------------");
    Console.WriteLine();

    // Let the moose speak!
    MooseSays("H I, I'M  E N T H U S I A S T I C !");
    MooseSays("I really am enthusiastic");

    // Ask a question
    bool isTrue = MooseAsks("Is Canada real?");
    if (isTrue)
    {
        MooseSays("Really? It seems very unlikely.");
    }
    else
    {
        MooseSays("I  K N E W  I T !!!");
    }
    ```

## Phase 7

Let's add multiple questions. We could do that at the top of the file, but that would make the code very long, cumbersome and hard to read. Instead, we should keep our code small and also gain the benefit of modularity by adding new functions for our questions.

1. Refactor the program to move the question into it's own function and call the new function.

    ```cs
    Console.WriteLine("Welcome to the Enthusiastic Moose Simulator!");
    Console.WriteLine("--------------------------------------------");
    Console.WriteLine();

    // Let the moose speak!
    MooseSays("H I, I'M  E N T H U S I A S T I C !");
    MooseSays("I really am enthusiastic");

    // As a question
    CanadaQuestion();


    void CanadaQuestion()
    {
        bool isTrue = MooseAsks("Is Canada real?");
        if (isTrue)
        {
            MooseSays("Really? It seems very unlikely.");
        }
        else
        {
            MooseSays("I  K N E W  I T !!!");
        }
    }
    ```

1. Add a few more questions. Feel free to copy and paste the code below and/or make up your own questions.

    ```cs
    void EnthusiasticQuestion()
    {
        bool isEnthusiastic = MooseAsks("Are you enthusiastic?");
        if (isEnthusiastic)
        {
            MooseSays("Yay!");
        }
        else
        {
            MooseSays("You should try it!");
        }
    }
 
    void LoveCSharpQuestion()
    {
        bool doesLoveCSharp = MooseAsks("Do you love C# yet?");
        if (doesLoveCSharp)
        {
            MooseSays("Good job sucking up to your instructor!");
        }
        else
        {
            MooseSays("You will...oh, yes, you will...");
        }
    }
 
    void SecretQuestion()
    {
        bool wantsSecret = MooseAsks("Do you want to know a secret?");
        if (wantsSecret)
        {
            MooseSays("ME TOO!!!! I love secrets...tell me one!");
        }
        else
        {
            MooseSays("Oh, no...secrets are the best, I love to share them!");
        }
    }
    ```

1. Call your new functions

    ```cs
    // Ask some questions
    CanadaQuestion();
    EnthusiasticQuestion();
    LoveCSharpQuestion();
    SecretQuestion();
    ```

## Phase 8

Notice the code at the top of our file - the `Console.WriteLine()`s and the calls to our functions. This is the code that immediately begins running when our program starts. It isn't contained in a function. It's just kinda...sitting there...at the top of the file.

You might be surprised to learn that this is a feature of C# that was only recently added. It's called "Top-level Statements". The feature allows us to write code at the "top-level" of our file. It's an excellent feature that allows us to get started quickly without any ceremony, but after a while it starts to become rather ungainly, and it's definitely not _idiomatic_ C# code.

Latter in the course, we'll see the more traditional place to put startup code, but for now, let's just put the code in a function. 

> **NOTE:** We call this _wrapping_ the code in a function.

```cs
Main();

void Main()
{
    Console.WriteLine("Welcome to the Enthusiastic Moose Simulator!");
    Console.WriteLine("--------------------------------------------");
    Console.WriteLine();

    // Let the moose speak!
    MooseSays("H I, I'M  E N T H U S I A S T I C !");
    MooseSays("I really am enthusiastic");

    // As a question
    CanadaQuestion();
    EnthusiasticQuestion();
    LoveCSharpQuestion();
    SecretQuestion();
}
```

> **NOTE:** Don't forget to call the `Main()` function.

## Phase 9 - A Challenge

Our moose is finally both enthusiastic and inquisitive, but the code for asking each question is a little redundant.

Refactor the app to reduce the redundancy in the code.

## Advanced Challenge

[Magic Moose](./MAGIC_MOOSE.md)

## Advanced Challenge 2

[Rock Paper Scissors](./ROCK_PAPER_SCISSORS.md)
