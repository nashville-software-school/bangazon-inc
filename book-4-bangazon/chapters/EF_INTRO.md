# Entity Framework

Entity Framework (EF) is an ORM that is different from Dapper, in that you don't write any SQL at all. You use LINQ methods in conjunction with your data models to instruct EF what you want to do with the data in your database. EF then determines the SQL syntax needed to perform the appropriate action(s).

Here's an example showing the different between the two ORMs. This example selects all of the departments from the Bangazon database.

## Select all Departments

#### Dapper Example

```cs
public async Task<IActionResult> Index () {
    using (IDbConnection conn = Connection) {
        IEnumerable<Department> departments = await conn.QueryAsync<Department> (
            "SELECT DepartmentId, Name FROM Department"
        );
        return View (departments);
    }
}
```

#### EF Example

```cs
public async Task<IActionResult> Index()
{
    return View(await _context.Department.ToListAsync());
}
```

## Create New Department

You also create new database entries with other methods that abstract the SQL away from you - the `Add()` and `SaveChangesAsync()` methods.

#### Dapper Example

```cs
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> Create (Department department) {
    if (ModelState.IsValid) {
        string sql = $@"
            INSERT INTO Department
                ( Id, Name )
                VALUES
                ( null, '{department.Name}' )
            ";

        using (IDbConnection conn = Connection) {
            int rowsAffected = await conn.ExecuteAsync (sql);

            if (rowsAffected > 0) {
                return RedirectToAction (nameof (Index));
            }
        }
    }

    return View (department);
}
```

#### EF Example

```cs
[HttpPost]
[ValidateAntiForgeryToken]
public async Task<IActionResult> Create(Department department)
{
    if (ModelState.IsValid)
    {
        _context.Add(department);
        await _context.SaveChangesAsync();
        return RedirectToAction(nameof(Index));
    }
    return View(department);
}
```

## The Cost of Convenience

While the simpler syntax may seem like a breath of fresh air, and much easier to read (_once you get used to it_), you pay for it with poorer performance. The SQL generated by EF is a sore spot by many developers because there are cases where it is not as fast and optimized as it would be if written out in long-form by the developer using Dapper.

* [Dapper vs Entity Framework vs ADO.NET Performance Benchmarking](https://www.exceptionnotfound.net/dapper-vs-entity-framework-vs-ado-net-performance-benchmarking/)
* [Performance: Entity Framework 7 vs. Dapper.net vs. raw ADO.NET](https://ppanyukov.github.io/2015/05/20/entity-framework-7-performance.html)

## Tutorial

Please do the [ASP.NET Core MVC with Entity Framework Core - Tutorial](https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/intro?view=aspnetcore-2.1) in which you will build a small web application using EF. It shows you how to configure your application for using it, how to set up a database context, and how to use that database context with LINQ statements to interact with a database.
